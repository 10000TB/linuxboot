#!/usr/bin/perl
# Extract all of the files from a UEFI firmware image.
#
# This is a simple replacement for uefi-firmware-parser
# with fewer features and more suited for reconstituting the
# firmware later.
#
use warnings;
use strict;
use FindBin;
use lib "$FindBin::Bin/../lib";
use EFI;
use Getopt::Long;
use File::Basename;
use Data::Dumper;


my $start_offset = 0; # 0x02c00000;
my $verbose = 0;

local $/;
while(<>)
{
	process_region("rom", $_, $start_offset);
}

sub process_region
{
	my $base = shift;
	my $data = shift;
	my $start_offset = shift || 0;
	my $length = length($data);

	warn sprintf "%s: length 0x%x bytes\n", $base, $length;
	my $start_unknown;


	# Search for the start of firmware volumes,
	# identified by their '_FVH' in the structure

	for(my $offset = $start_offset ; $offset < $length - 0x30 ; $offset += 16)
	{
		my $signature = substr($_, $offset + 0x28, 4);
		my $fv_length = EFI::read64($_, $offset + 0x20);

		if ($signature ne '_FVH' or $offset + $fv_length > $length)
		{
			# likely not a filesystem; report an unknown region
			# if we have started processing filesystems
			$start_unknown ||= $offset;
			next;
		}

		if (defined $start_unknown)
		{
			# We have a unknown region to write out
			my $len = $offset - $start_unknown;
			my $data = substr($_, $start_unknown, $len);
			warn sprintf "%s: 0x%08x unknown region 0x%x bytes\n",
				$base, $offset, $len;

			output(sprintf("%s/0x%08x.bin", $base, $start_unknown), $data);
			undef $start_unknown;
		}

		my $fv = substr($data, $offset, $fv_length);
		output(sprintf("%s/0x%08x.fv", $base, $offset), $fv);

		process_fv(sprintf("%s/0x%08x", $base, $offset), $fv);

		# skip to the end of the filesystem
		# should we care if this FV is not processed?
		$offset += $fv_length - 16;
	}
}


sub process_fv
{
	my $base = shift;
	my $fv = shift;
	my $fv_length = length $fv;

	my $offset = EFI::read16($fv, 0x30);
	if ($offset >= $fv_length)
	{
		warn sprintf "%s: FV invalid data offset 0x%04x\n",
			$base, $offset;
		return 0;
	}

	my $guid = EFI::read_guid($fv, 16);

	warn sprintf "%s: FV length 0x%x %s\n",
		$base,
		$fv_length,
		$guid,
		;

	if ($guid ne '8c8ce578-8a3d-4f1c-9935-896185c32dd3')
	{
		# we can only process normal firmware volumes
		return;
	}

	while($offset < $fv_length - 0x20)
	{
		my $len = EFI::read24($fv, $offset + 0x14);
		my $data_offset = 0x18;

		if ($len == 0xFFFFFF)
		{
			# Version 2 header with extended length
			$len = EFI::read64($fv, $offset + 0x18);

			# If we have an all-0xFF length, which indicates
			# the start of free space
			return 1 if ~$len == 0;

			## Looks good, adjust the starting offset
			$data_offset += 0x8;
		}

		if ($len == 0x0)
		{
			warn sprintf "%s: 0x%08x file has zero length?\n",
				$base,
				$offset;
			return 0;
		}

		if ($len + $offset > $fv_length)
		{
			warn sprintf "%s: 0x%08x file len 0x%x exceeds FV len\n",
				$base,
				$offset,
				$len;
			return 0;
		}

		
		my $data = substr($fv, $offset, $len);

		process_ffs($base, $data, $data_offset);

		$offset += $len;

		# align it
		$offset = ($offset + 7) & ~7;
	}

	return 1;
}


sub process_ffs
{
	my $base = shift;
	my $ffs = shift;
	my $data_offset = shift; # might be 0x18 or 0x20
	my $len = length($ffs);

	my $guid = EFI::read_guid($ffs, 0x00);

	if ($guid eq 'ffffffff-ffff-ffff-ffff-ffffffffffff')
	{
		# padding: do not output it
		# should check that everything is 0xFF first
		return;
	}

	output("$base/$guid.ffs", $ffs);

	my @sections = ffs_sections("$base/$guid", $ffs, $data_offset);

	# if this file has a UI section, extract its name
	my $name = '';
	for my $sec (@sections)
	{
		next unless $sec->[0] eq 'USER_INTERFACE';
		#$name = Dumper($sec->[1]); # EFI::read_ucs16($sec->[1], 2);
		$name = EFI::read_ucs16($sec->[1], 0);
	}

	warn sprintf "%s/%s: %s\n", $base, $guid, $name;


#	if ($guid eq '8c8ce578-8a3d-4f1c-9935-896185c32dd3')
#	{
#		# recursively expand embedded, compressed fv
#		process_ffs_fv($base, $ffs, $data_offset);
#	} else {
#		# todo: Look for a UI section to produce a nice table
#	}
}


sub ffs_sections
{
	my $base = shift;
	my $ffs = shift;
	my $offset = shift;
	my $ffs_len = length($ffs);

	my @sections;

	# find each section inside 
	while($offset < $ffs_len - 8)
	{
		my $len = EFI::read24($ffs, $offset);
		my $data_offset = 0x4;
		if ($len == 0xFFFFFF)
		{
			# FFSv3 section
			$len = EFI::read32($ffs, $offset + $data_offset);
			$data_offset += 4;
		}

		if ($len < $data_offset)
		{
			die sprintf "%s: 0x%x Section length %x invalid\n", $base, $offset, $len;
		}

		if ($offset + $len > $ffs_len)
		{
			die sprintf "%s: Section length %x exceeds FFS len %x\n",
				$base,
				$len,
				$ffs_len,
				;
		}

		my $sec = substr($ffs, $offset, $len);

		# move to the next section, keeping a 4-byte alignment
		$offset = ($offset + $len + 3) & ~3;

		my $sec_type = ord(substr($sec, 3, 1));
		my $sec_data = substr($sec, $data_offset, $len - $data_offset);

		my $sec_type_name = $EFI::section_types_lookup{$sec_type};
		$sec_type_name ||= sprintf "0x%02x", $sec_type;

		warn sprintf "%s: %s len %x\n", $base, $sec_type_name, $len
			if $verbose;

		push @sections, [ $sec_type_name, $sec_data ];
	}

	return @sections;
}


sub output
{
	my $name = shift,
	my $data = shift;

	my $dir = dirname($name);
	system(mkdir => -p => $dir)
		and die "$name: Unable to create directory\n";
	open FILE, '>', "$name"
		or die "$name: Unable to create output file: $!\n";
	print FILE $data;
	close FILE;
}
